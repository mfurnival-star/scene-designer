Scene Designer â€“ Engineering & Review Rules

1. ES Module Only
- Use ES module syntax for all imports/exports.
- No window.*, no global variables, no CDN/global scripts.
- External dependencies (e.g. Fabric.js, Pickr, Tweakpane) must be installed via npm and imported.

1A. Remote Logging Exception
- For remote log streaming: inject Console.Re connector.js CDN script in <head>.
- Only for remote logging; remove when Console.Re provides an ES module export.
- Do not use legacy console-remote-client except for old builds.
- Document this exception in build/deploy scripts.

2. Import/Export Consistency
- Every import must match a real export in the source file.
- Update source or imports to ensure consistency.
- No importing non-exported symbols.

3. File Delivery and Review
- Deliver complete files only, one at a time, in numbered order.
- Do not deliver code snippets, partial code blocks, or fragments. Only deliver the complete content of the requested file.
- After each file, state the next file and wait for confirmation ("next"/"ready").
- Keep a running list of remaining files.
- After all files, state completion.
- Update src/modules.index.md when adding/removing/renaming modules.

4. File Size/Splitting
- No file over ~500 lines; split large files into logical modules.
- Prefer splitting by concern (core, UI, helpers, etc).
- Each module starts with a summary comment.
- Update imports/exports and src/modules.index.md after splitting.

5. Logging/Documentation
- Use log() from log.js with levels: ERROR, WARN, INFO, DEBUG.
- TRACE is deprecated; use DEBUG for verbose logs.
- No direct console.log except inside logger.
- Every file starts with a summary comment (purpose, exports, dependencies).

6. State Management
- Use exported functions/store object from state.js (Zustand-style).
- No AppState singletons.
- Use getState(), mutators, and sceneDesignerStore.subscribe(fn).

7. Separation of Concerns
- UI emits intents/actions only; no direct state mutation.
- All business logic for scene actions (add, delete, duplicate, lock, unlock, etc) is in actions.js.
- Cross-module communication via ES module imports/exports.

8. Manifest/Documentation
- Update src/modules.index.md for all module changes.

--- NEW: Phased Architecture Path for Studio-Grade Flexibility ---
To ensure Scene Designer remains scalable, maintainable, and professional-grade, we commit to the following phased architecture path. Each phase delivers incremental stability, extensibility, and testability, without requiring a disruptive rewrite.

**Phase 1: Stabilize Selection and Geometry**
- Use transactional (tokenized) selection sync between Fabric and store to eliminate reentrancy bugs.
- Centralize geometry computations (absolute rects, bounds, hulls) in shared utilities, adopted by alignment, overlays, and selection logic.

**Phase 2: Command Layer and History**
- Introduce a minimal command bus: all core actions (select, align, move, lock, delete, duplicate) become commands with pure signatures.
- Actions.js delegates to commands; history stack supports undo/redo.

**Phase 3: Model-Driven Selection**
- Treat the model (store) as the single source of truth for shapes and selection.
- Fabric becomes a pure input/view adapter: input events dispatch intents, selection is mirrored from model to Fabric.
- Eliminate double writes and handler suppression for selection.

**Phase 4: Centralize Geometry and Hit-Testing**
- All modules (alignment, overlays, constraints, marquee) use the shared geometry library, not Fabric's bounding APIs directly.
- Marquee selection is computed in the model, making hit-testing and selection policies deterministic.

**Phase 5: Full Domain Model for Shapes**
- Shapes, transforms, selection set, and scene state are plain objects in the model.
- The view adapter maps model state to Fabric objects; business logic never depends on Fabric's internal state.
- Fabric's ActiveSelection used only for visuals.

**Phase 6: History, Persistence, and Plugins**
- All commands support undo/redo.
- Scenes serialize/deserialize from model, not Fabric.
- Tool/command registry allows clean plugin/extensibility.

**Guiding Principle:**  
At every phase, prioritize testability, separation of concerns, and extensibility.  
No business logic or state lives in UI or Fabric handlers; all domain logic is centralized and pure.

**Deviation from this path requires explicit engineering review and justification.**

--- End Phased Architecture Section ---

Refer to this file before making foundational changes.  
Always update this section if the architectural path is revised.
